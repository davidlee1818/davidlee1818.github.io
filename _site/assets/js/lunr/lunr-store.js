var store = [{
        "title": "搭建博客之第一天",
        "excerpt":"第一篇博客  为了用个jekyll模板，ubuntu折腾了一天。中间遇到一些bug贼痛苦，记录下来也许对别人有点用处。  坑点     Ubuntu各种黑屏   速度拉跨的gems源   bundle install 提示找不到openssl                                                                                                                                This is a sample gallery to go along with this case study.       解决ubuntu各种黑屏  方法一  $&gt; vim /etc/default/grub    增加nomodeset到GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash nomodeset\"    $&gt; sudo update-grub    $&gt; sudo reboot\t  这个方法禁止虚拟机检测显卡，设置后屏幕可能很难看。   方法二  管理员cmd&gt; netsh winsock reset     将winsock的目录重置为默认的设置状态。虚拟机与主机之间的通信方式是以socket进行的。 可能会因为某个程序通过LSP注入DLL,导致回收不彻底。影响虚拟的运行。因此需要进行这些注入DLL的残留清理重置。 这个方法虚拟机显示效果更好，但是会重置防火墙设置 hosts文件变成只读。  没用！！ 事实上虚拟机重启它就黑屏，宿主机重启才能正常进入虚拟机可视化界面，尝试调整虚拟机显示可用内存试试。    另外，有可能之前安装就一直黑屏，如果是vmware 建议用原生的模拟磁盘安装（选稍后自行安装），自动安装贼坑。 卡在retrieving file 可以 skip 不然等一年！    更换gems国内源  $&gt; gem sources -l     $&gt; gem sources -r   //加上上面的干掉官方源     $&gt; gem sources -a 'https://gems.ruby-china.com'  //目前可用的国内源     另外gem在update 或者 bundle install的时候 也会使用默认源。     $&gt; bundle config 'mirror.https://rubygems.org' 'https://gems.ruby-china.com' 会在你 ~/.bundle 生成对应配置文件，而不需要去改Gemfile     安装jekyll和theme的依赖  这个坑奇坑无比！！  明明安装了openssl，他就是找不到你气不气    $&gt; sudo gem install eventmachine -v '1.2.7' --source 'https://gems.ruby-china.com' -- --with-cppflags=-I/usr/local/opt/openssl/include  参数设置也是贼坑，看帮助完全没用！！ 注意 两个'--'不能少 还有空格。 模板用的github mmistakes大佬的jekyll-theme-skinny-bones，装完ruby、rubygems、bundle 之后，解压大佬的zip包 bundle install 安装好 jekyll 就可以自己写博客啦！！    编译: $&gt;bundle exec jekyll build      开启服务器: $&gt;bundle exec jekyll serve      默认本机 127.0.0.0:4000  绑定的本机内网 宿主机进不去的。   tips：有些时候需要强制jekyll生产模式下运行，用来开启一些功能 比如：评论 等。  $&gt; JEKYLL_ENV=production bundle exec jekyll build  makedown还不熟估计版式贼丑。   模板换成大佬最新的 minimal-mistakes。   ","categories": [],
        "tags": [],
        "url": "/build-blog/first-day/",
        "teaser": "/assets/images/build-blog-01.jpg"
      },{
        "title": "搭建博客之第二天",
        "excerpt":"博客实现评论及验证  大佬帖子先贴上 点这    流程原理：     客户端网页渲染器通过post请求提交评论表单，js附加表单信息提交到运行在Heroku上的staticman (API bridge).   云端staticman保持着一份local git-repo(第一次是从你的blog-repo clone 到本地的)。   收到评论时会同步到bot账号的github仓库,并发起pull请求到你的博客仓库，然后需要博客账号同意merge。    当你同意merge之后，会立即触发github pages立即更新并发布你的网页内容(这是github pages的特性)，刷新后评论立刻就会出现。   建一个bot账号（普通账号）用户  为了能实现上述流程，因此需要用你的博客账号把bot账号拉到协作者团队中，允许bot修改你的博客仓库。   同时生成github Personal access tokens,勾选repo和users scope.   google recaptcha实验验证功能  https://www.google.com/recaptcha/admin 翻墙注册博客域名 拿到sitekey和screte   sitekey:在您的网站提供给用户的 HTML 代码中使用此网站密钥。  screte:此密钥用于您的网站和 reCAPTCHA 之间的通信(staticman 还会对它再加密)    //使用之前部署在heroku的staticman加密recaptcha的screte https://${bridge_app_name}.herokuapp.com/v2/encrypt/{$recaptcha-site-secret}  将sitekey和加密后screte正确设置到jekyll的_config.yml中。 记得将html中的goog recaptcha中的js源改成国内的，不然无法通过验证（被墙了）。 将www.google.com改成www.recaptcha.net   通过heroku实现私人staticman服务  这个网站是真厉害，你可以部署你的服务在上面实时运行，甚至可以自定义pipline，统计分析、机器学习都能用得上。 现在你要为staticman添加参数配置：     在本机生成rsa密钥对，staticman会用公钥来加密你的reCAPTCHA screte的公共部分，之后使用私钥进行解密。   登录heroku的cli，可以使用web端设置，也可以下载heroku的client登录。cli设置如下：     //staticman无法处理换行,需要处理掉\\n 和 / heroku config:add --app ${bridge_app_name} \"RSA_PRIVATE_KEY=$(cat ~/.ssh/staticman_key | tr -d '\\n')\" heroku config:add --app ${bridge_app_name} \"GITHUB_TOKEN=${github_token}\" heroku config --app ${bridge_app_name} //验证参数设置是否正确           邀请bot账户至协作者团队 blog-repo -&gt; Settings -&gt; manage access -&gt; invate a collaborator     //浏览器中输入以下地址, ${bridge_app_name}是你heroku上的应用名 后两个参数你是博客的用户名和仓库名 https://${bridge_app_name}.herokuapp.com/v2/connect/${github-username}/${blog-repo}          当出现OK！就说明邀请成功了(只会显示一次，之后再刷新就会提示邀请找不到)，事实上你也可以手动通过bot账号的邮件同意邀请。 不过通过heroku同意也证明了我们之前的设置是有效的。       现在你的博客就可以实现评论功能了！！！   ","categories": [],
        "tags": [],
        "url": "/build-blog/second-day/",
        "teaser": "/assets/images/build-blog-02.jpg"
      },{
        "title": "搭建博客之第三天",
        "excerpt":"alglia     将jekyll-algolia添加到你Gemfile以及jekyll_plugins中，如下：     group :jekyll_plugins do   gem \"jekyll-feed\"   gem \"jekyll-seo-tag\"   gem \"jekyll-sitemap\"   gem \"jekyll-paginate\"   gem \"jekyll-include-cache\"   gem \"jekyll-algolia\" end          之后在命令行执行bundle install，安装好相应的依赖库。       在你的_config.yml中修改如下：     search_provider: algolia           将algolia的认证信息添加到_config.yml     algolia:   application_id: # YOUR_APPLICATION_ID   index_name: # YOUR_INDEX_NAME   search_only_api_key: # YOUR_SEARCH_ONLY_API_KEY   powered_by: # true (default), false          如果你没有algolia账号，去注册一个并启用一个免费的社区计划。 从你的dashboard中获取认证信息。       当你的认证信息配置好之后，就可以通过以下命令去执行algolia的索引编排     ALGOLIA_API_KEY=your_admin_api_key bundle exec jekyll algolia          对于windows用户，你应该通过set设置ALGOLIA_API_KEY环境变量      set ALGOLIA_API_KEY=your_admin_api_key bundle exec jekyll algolia          注意ALGOLIA_API_KEY应该是你的admin API key。       Travis  启用Travis  Travis CI 是一个托管的持续集成的服务，并且是开源免费的项目。你可以通过它监听Github仓库的任何变化，并执行一个特殊的命令反馈回去。 正如上面一样如果每次更新索引库都需要我们手动执行  ALGOLIA_API_KEY=your_admin_api_key bundle exec jekyll algolia  会变得很麻烦。不过别担心，Travis CI可以帮助你完成这个工作。在你每次push到github仓库中时它会自动帮你执行jekyll algolia来实时更新。 接下来是你要执行的一些步骤：     注册登录travis-ci.org(可以直接使用github账户登录)   点击你的头像和简介   从列表中找到你的github仓库并启用    取消勾选’Build pull request updates’选项，防止每次你收到pull请求是重新编排索引(评论会触发pull request)   配置Travis  现在Travis已经启用了，通过.travis.yml文件配置到你的仓库的根目录下，将会使你更容易追踪配置信息，尽管你可以通过Travis UI去配置，但是并不推荐。   # .travis.yml # This file should be at the root of your project language: ruby cache: bundler before_install:   - gem install bundler script:   - bundle exec jekyll algolia branches:   only:     # Change this to gh-pages if you're deploying using the gh-pages branch     - master rvm:  - 2.4'   通过.travis.yml文件Travis能够使用Bundler获得你定义在Gemfile中的所有依赖，然后执行bundle exec jekyll algolia对你的数据自动排序。 设置branches.only的值，你可以选择只对Github仓库的某个分支生效，通常来说都是master，取决于你Github pages发布在哪里。   忽略vendor  Travis将他的服务端vendor目录下所有gems打包，因此Jekyll可以能会错误的读取，这可能会导致执行失败。为了避免这种情况，你应该将vendor配置到_config.yml的exclude列表中。  exclude: [vendor]  添加ALGOLIA_API_KEY  通过WebUI Travis Settings页面将你的ALGOLIA_API_KEY作为环境变量传给Travis。   接下来让我们验证一下，提交你所有的修改并push到Github远程仓库，Travis会抓取push事件并触发一个自动排序。你可以通过Travis dashboard查看作业执行的完整日志。   ","categories": [],
        "tags": [],
        "url": "/build-blog/third-day/",
        "teaser": "/assets/images/build-blog-03.jpg"
      },]
